Go语言的变量逃逸分析是编译器对内存管理进行的优化和简化。它决定一个变量是分配在堆上还是分配在栈上。
如果一个变量的指针被多个函数或线程引用，或者一个函数返回对一个变量的引用，那么这个变量就会发生逃逸，分配在堆上。

在您的例子中，x是一个局部变量，本来应该分配在栈上。但是因为您将x的地址赋给了z，而z是一个指针变量，它可能被其他函数或线程引用，
所以x就发生了逃逸，分配在堆上。这样做的好处是可以避免x在函数返回后被销毁，导致z指向无效内存。

y是用**new**函数创建的指针变量，它指向一个分配在堆上的int64类型的值。new函数的作用是在**堆**上分配内存，并返回指向该内存的指针。所以y分配在堆上。

z是一个局部变量，它的值是x的地址。z本身没有发生逃逸，所以它分配在栈上。但是z指向的x发生了逃逸，所以x分配在堆上。

**这是因为如果一个变量的指针被多个函数或线程引用，或者一个函数返回对一个变量的引用，那么这个变量的生命周期就不再受到函数栈帧的限制，它可能在函数返回后还被使用。** 如果这个变量分配在栈上，那么它就会在函数返回后被销毁，导致指针指向无效内存。
为了避免这种情况，编译器会将这种变量分配在堆上，堆上的内存是由垃圾回收器管理的，不会被随意销毁。
